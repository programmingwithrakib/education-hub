
### üü¢ **Section 1: Getting Started with Bash (1‚Äì8)**

**1. What is Bash?**  
‚Üí Intro to Shell, Terminal, and Bash Environment  
üí° _Practice:_ Open terminal and identify your shell with `echo $SHELL`

**2. Installing & Setting Up Bash Environment**  
‚Üí macOS, Linux, Windows (WSL) setup  
üí° _Practice:_ Configure your `.bashrc` or `.bash_profile`

**3. Understanding Shell Commands & Syntax**  
1. What is a shell command
    
2. Command structure (command, options, arguments)
    
3. Built-in vs external commands
    
4. Command execution process (how Bash reads & runs commands)
    
5. Using `;`, `&&`, `||` to chain multiple commands
    
6. Whitespace and syntax importance
    
7. Quoting rules: single (`'`), double (`"`), and escaping (`\`)
    
8. Command substitution: `$( )` and backticks `` ` ` ``
    
9. Exit status and `$?` usage
    
10. Common special characters (`$`, `#`, `*`, `|`, `>`, `<`, `;`)
    
11. Environment variables in commands (`$USER`, `$HOME`, `$PWD`)
    
12. Writing clean, readable command lines
    
13. Common syntax mistakes beginners make

**4. Navigating the Filesystem**  
- What is a filesystem (directory tree overview)
    
- Understanding absolute vs relative paths
    
- The meaning of `/`, `~`, `.`, and `..`
    
- Viewing current location (`pwd`)
    
- Listing files and directories (`ls`, `ls -l`, `ls -a`, `ls -lh`)
    
- Moving between directories (`cd`, `cd ..`, `cd -`, `cd ~`)
    
- Creating and removing directories (`mkdir`, `rmdir`)
    
- Creating, copying, and moving files (`touch`, `cp`, `mv`)
    
- Removing files and folders (`rm`, `rm -r`)
    
- Viewing file structure visually (`tree` command)
    
- Using tab auto-completion for paths
    
- Using wildcards (`*`, `?`) for file matching
    
- Checking file details (`file`, `stat`)
    
- Navigating hidden files and directories (`ls -a`)
    
- Combining navigation with commands (e.g., `cd ~/Downloads && ls`)
    
- Using shortcuts and aliases for frequent paths
    
- Exploring system directories (`/home`, `/etc`, `/usr`, `/bin`)
    
- Common mistakes (like `rm -rf /` üòÖ ‚Äî with warning)
    
- Hands-on demo: create a folder structure and navigate it
    
- Recap: ‚ÄúYou must master navigation before automation‚Äù

**5. Creating & Managing Files**  
- What is a file in Linux (everything is a file concept)
    
- Understanding file types (`ls -l` ‚Üí `-`, `d`, `l`, etc.)
    
- Creating empty files (`touch`, `>`)
    
- Creating files with content (`echo "text" > file.txt`, `cat > file.txt`)
    
- Viewing file contents (`cat`, `less`, `more`, `head`, `tail`)
    
- Copying files (`cp file1 file2`, `cp -r folder1 folder2`)
    
- Moving or renaming files (`mv old.txt new.txt`)
    
- Deleting files and folders (`rm`, `rm -r`, `rmdir`)
    
- Creating nested directories (`mkdir -p project/src/assets`)
    
- Checking file details (`ls -lh`, `stat filename`)
    
- Editing files from terminal (`nano`, `vim`, `echo >>`)
    
- Redirecting output to create/update files (`>`, `>>`)
    
- File overwrite warning and safe operations (`cp -i`, `mv -i`, `rm -i`)
    
- Creating symbolic links and hard links (`ln -s`, `ln`)
    
- File search commands (`find`, `locate`)
    
- Displaying file size and disk usage (`du -sh`, `df -h`)
    
- Working with hidden files (`.env`, `.bashrc`, `ls -a`)
    
- Creating multiple files/folders at once using brace expansion (`touch file{1..5}.txt`)
    
- File naming conventions and best practices
    
- Practical demo: Create ‚Üí Edit ‚Üí Move ‚Üí Delete cycle

**6. Input, Output & Redirection**  
1. What is Input and Output in Bash
    
2. Understanding standard streams:
    
    - **stdin (0)** ‚Üí input
        
    - **stdout (1)** ‚Üí normal output
        
    - **stderr (2)** ‚Üí error output
        
3. Redirecting standard output to a file (`>`)
    
4. Appending output to an existing file (`>>`)
    
5. Redirecting input from a file (`<`)
    
6. Redirecting error output (`2>`, `2>>`)
    
7. Redirecting both output and errors (`&>`, `2>&1`)
    
8. Using `/dev/null` to discard output
    
9. Combining multiple redirections in one command
    
10. Difference between `>` and `>>`
    
11. Using pipes (`|`) to connect commands
    
12. Real-world examples of piping (`ls | grep`, `ps aux | grep`)
    
13. Using `tee` command to write and display output simultaneously
    
14. Here-document (`<<EOF`) and Here-string (`<<<`) concepts
    
15. Interactive input vs file input examples
    
16. Command substitution inside redirection (`echo $(date) > log.txt`)
    
17. Error handling with redirection (logging errors separately)
    
18. Viewing combined output logs (`cat output.log error.log`)
    
19. Practical example: redirecting script logs to files
    
20. Summary: mastering redirection = mastering automation

**7. Pipes & Filters**  
- What are pipes (`|`) and filters ‚Äì basic concept
    
- How data flows between commands using pipes
    
- Difference between redirection (`>`) and pipes (`|`)
    
- Simple pipeline examples (`ls | wc -l`, `cat file | grep word`)
    
- Chaining multiple commands together (`cat file | grep "error" | sort | uniq`)
    
- Common filter commands overview:
    
    - `cat` ‚Üí display content
        
    - `grep` ‚Üí search text
        
    - `sort` ‚Üí sort lines
        
    - `uniq` ‚Üí remove duplicates
        
    - `cut` ‚Üí extract columns
        
    - `head`, `tail` ‚Üí limit lines
        
    - `tr` ‚Üí translate/replace characters
        
- Filtering case-insensitive matches (`grep -i`)
    
- Using pipes with `less` or `more` for long outputs
    
- Counting words, lines, and characters (`wc`, `wc -l`, `wc -w`)
    
- Combining filters for real tasks (log parsing examples)
    
- Using pipes with system commands (`ps aux | grep bash`)
    
- Using `tee` to view and save piped output
    
- Nested pipes and performance considerations
    
- Practical example:
    
    - Find all `.log` files
        
    - Filter errors
        
    - Count occurrences
        
- Bonus: using pipes in scripts and cron jobs
    
- Common mistakes (forgetting `|`, mixing with `>`)
    
- Summary: ‚ÄúPipe connects, filter refines ‚Äî that‚Äôs Bash power!‚Äù

**8. Permissions & Ownership**  
1. What are file permissions and why they matter
    
2. Understanding permission symbols (`r`, `w`, `x`)
    
3. Permission structure breakdown (`-rw-r--r--`)
    
4. File types in permission string (`-`, `d`, `l`)
    
5. User categories:
    
    - **Owner (u)**
        
    - **Group (g)**
        
    - **Others (o)**
        
6. Viewing permissions with `ls -l`
    
7. Changing permissions using `chmod` (symbolic & numeric)
    
    - Symbolic: `chmod u+x file.sh`
        
    - Numeric: `chmod 755 file.sh`
        
8. Common numeric permission values (e.g., 644, 755, 777)
    
9. Recursive permission changes (`chmod -R`)
    
10. Changing file ownership (`chown user file`)
    
11. Changing group ownership (`chgrp group file`)
    
12. Combining ownership changes (`chown user:group file`)
    
13. Checking current user and group (`whoami`, `id`)
    
14. Understanding `umask` (default permission behavior)
    
15. Special permissions:
    

- **SUID (4)**
    
- **SGID (2)**
    
- **Sticky bit (1)**
    

16. Security risks of `chmod 777`
    
17. Managing permissions on directories vs files
    
18. Viewing permissions in octal form (`stat -c "%a %n" file`)
    
19. Best practices for secure permission management
    
20. Practical demo: create ‚Üí set ‚Üí restrict ‚Üí verify permissions

---

### üü° **Section 2: Bash Scripting Fundamentals (9‚Äì16)**

**9. Writing Your First Bash Script**  
- What is a Bash script
    
- Why we use scripts (automation, reusability, efficiency)
    
- Understanding the shebang line (`#!/bin/bash`)
    
- Creating a new script file (`touch script.sh`, `nano script.sh`)
    
- Writing simple commands inside the script (`echo`, `ls`, `pwd`)
    
- Saving and giving execute permission (`chmod +x script.sh`)
    
- Running a script (`./script.sh`, `bash script.sh`)
    
- Difference between `bash script.sh` vs `./script.sh`
    
- Using comments (`#`) for documentation
    
- Understanding script execution flow (top to bottom)
    
- Printing text and variables using `echo`
    
- Adding blank lines and formatting output
    
- Using multiple commands inside one script
    
- Handling errors & exit codes (`exit 0`, `exit 1`)
    
- Checking current shell and script interpreter (`echo $0`)
    
- Using relative vs absolute paths inside scripts
    
- Creating scripts in different directories and running them
    
- Creating a ‚ÄúHello World‚Äù script (first working demo)
    
- Adding environment info (like current date, user, path)
    
- Best practices for beginners: naming, indentation, and comments

**10. Variables & Constants**  
- What are variables in Bash
    
- Declaring a variable (`name="Rakib"`)
    
- Accessing variable values (`echo $name`)
    
- Naming rules for variables (no spaces, start with letters, etc.)
    
- Difference between **global** and **local** variables
    
- Using variables in strings (double quotes vs single quotes)
    
- Command substitution in variables (`today=$(date)`)
    
- Arithmetic with variables (`count=$((10 + 5))`)
    
- Reassigning and updating variable values
    
- Unsetting variables (`unset variable_name`)
    
- Constants using `readonly` or `declare -r`
    
- Checking all defined variables (`set`, `env`)
    
- Exporting variables to child processes (`export VAR=value`)
    
- Environment variables overview (`$PATH`, `$USER`, `$HOME`)
    
- Difference between local, environment, and shell variables
    
- Default values with parameter expansion (`${VAR:-default}`)
    
- Using variables in file paths or commands
    
- Best practices: quoting, naming, and readability
    
- Common mistakes (missing `$`, space around `=`)
    
- Hands-on demo: simple ‚ÄúUser Info‚Äù script using variables

**11. Command Substitution & Quoting**  
- What is command substitution
    
- Syntax: `` `command` `` vs `$(command)`
    
- Capturing command output into variables
    
- Using command substitution inside strings
    
- Nested command substitutions
    
- Command substitution with arithmetic or logic
    
- Practical examples (`date`, `whoami`, `wc -l`)
    
- Common mistakes in command substitution
    
- What is quoting and why it‚Äôs important
    
- Single quotes (`' '`) vs double quotes (`" "`)
    
- Using backslash (`\`) to escape special characters
    
- Quoting in echo statements
    
- Handling spaces in filenames with quotes
    
- Escaping quotes within quotes
    
- Using `$'\n'` and special characters
    
- Mixing quotes safely
    
- Best practices for quoting
    
- Combining command substitution and quoting
    
- Real-world examples (system info script)
    
- Recap: how quoting and substitution work together

**12. Conditional Statements**  
1. What are conditional statements in Bash
    
2. Purpose of conditionals (decision making in scripts)
    
3. Basic syntax of `if`, `elif`, `else`, `fi`
    
4. Using `then` in same or next line (`if [ ... ]; then`)
    
5. Testing conditions with `test` or `[ ]`
    
6. Using double brackets `[[ ... ]]` (advanced test syntax)
    
7. Numeric comparisons (`-eq`, `-ne`, `-gt`, `-lt`, `-ge`, `-le`)
    
8. String comparisons (`=`, `!=`, `-z`, `-n`)
    
9. File condition checks (`-f`, `-d`, `-e`, `-r`, `-w`, `-x`)
    
10. Combining conditions with `&&` and `||`
    
11. Nested `if` statements
    
12. Using `elif` for multiple conditions
    
13. Using logical NOT (`!`)
    
14. Short form one-line `if` statements
    
15. Using exit status in conditions (`if command; then ... fi`)
    
16. Practical examples (file exists, user check, directory creation)
    
17. Common mistakes (missing spaces, wrong brackets)
    
18. Best practices for readable conditions
    
19. Debugging conditional logic
    
20. Real-world demo: simple login or validation script

**13. Logical & Comparison Operators**  
- What are operators in Bash
    
- Difference between logical and comparison operators
    
- Numeric comparison operators:
    
    - `-eq` (equal)
        
    - `-ne` (not equal)
        
    - `-gt` (greater than)
        
    - `-lt` (less than)
        
    - `-ge` (greater or equal)
        
    - `-le` (less or equal)
        
- String comparison operators:
    
    - `=` (equal)
        
    - `!=` (not equal)
        
    - `-z` (string is empty)
        
    - `-n` (string is not empty)
        
- File comparison operators:
    
    - `-e` (exists)
        
    - `-f` (regular file)
        
    - `-d` (directory)
        
    - `-r`, `-w`, `-x` (read, write, execute permissions)
        
- Logical operators:
    
    - `&&` (AND)
        
    - `||` (OR)
        
    - `!` (NOT)
        
- Combining multiple conditions
    
- Grouping conditions with parentheses `()`
    
- Using operators inside `if`, `[[ ]]`, and `test`
    
- Difference between `-a`, `-o` and `&&`, `||`
    
- Evaluating arithmetic expressions with `$(( ))`
    
- Practical numeric comparison examples
    
- Practical string comparison examples
    
- Logical condition chaining demo
    
- Checking command success/failure using `$?`
    
- Short-circuit logic behavior in Bash
    
- Common mistakes (missing spaces, wrong operator placement)
    
- Using operators in scripts for validation or automation
    
- Best practices for clean and readable conditions
    
- Real-world example: compare file sizes or numeric inputs

**14. Loops ‚Äì For, While, Until**  
- What are loops and why they‚Äôre used
    
- Basic concept of iteration in Bash
    
- `for` loop syntax and structure
    
- Iterating over a list of values (`for i in 1 2 3`)
    
- Iterating using brace expansion (`for i in {1..10}`)
    
- Iterating through files or directories (`for file in *.txt`)
    
- Using C-style `for` loops (`for ((i=0; i<5; i++))`)
    
- `while` loop syntax and use cases
    
- Looping with conditions in `while`
    
- Reading user input inside a `while` loop (`while read line`)
    
- `until` loop syntax and use cases
    
- Difference between `while` and `until` loops
    
- Infinite loops and breaking conditions
    
- Using `break` to exit a loop early
    
- Using `continue` to skip an iteration
    
- Nested loops (loop inside another loop)
    
- Looping through command output (`for user in $(cat users.txt)`)
    
- Common mistakes in loop syntax (missing `do`, `done`)
    
- Practical examples:
    
    - Counting numbers
        
    - Reading lines from a file
        
    - Monitoring a process
        
- Best practices for efficient and safe loops

**15. Functions in Bash**  
- What is a function in Bash
    
- Why use functions (reusability & organization)
    
- Function syntax and declaration styles
    
    - `function name { ... }`
        
    - `name() { ... }`
        
- Calling a function
    
- Function naming rules and conventions
    
- Scope of variables inside functions (global vs local)
    
- Using `local` keyword for local variables
    
- Returning values from a function (`return` vs `echo`)
    
- Capturing function output in variables (`result=$(myFunc)`)
    
- Passing arguments to functions (`$1`, `$2`, `$@`)
    
- Checking number of arguments with `$#`
    
- Using `shift` to process multiple arguments
    
- Exit codes in functions and error handling
    
- Nested function calls (function calling another function)
    
- Defining functions in external files and sourcing them (`source utils.sh`)
    
- Function libraries (organizing reusable functions)
    
- Debugging functions with `set -x`
    
- Using `trap` inside functions for cleanup
    
- Best practices: naming, comments, modularity
    
- Practical examples:
    
    - Math calculator function
        
    - String formatter
        
    - Simple menu-driven function system

**16. Script Arguments & Parameters**  
- What are script arguments and why they‚Äôre used
    
- Passing arguments to a Bash script from the command line
    
    `./script.sh arg1 arg2`
    
- Accessing arguments inside a script (`$1`, `$2`, `$3`, ‚Ä¶)
    
- `$@` vs `$*` ‚Äî difference between all arguments
    
- Counting total arguments using `$#`
    
- Script name reference using `$0`
    
- Shifting arguments with `shift`
    
- Checking if arguments are provided or missing
    
- Default values for missing arguments (`${1:-default}`)
    
- Quoting arguments with spaces (`"./my folder"`)
    
- Using arguments inside conditions or loops
    
- Handling long argument lists dynamically
    
- Error messages and exit if invalid arguments passed
    
- Positional parameters and order sensitivity
    
- Using `read` for interactive argument fallback
    
- Validating numeric or string arguments
    
- Combining arguments with variables
    
- Using arguments for filenames, paths, or commands
    
- Real-world example:
    
    - `./backup.sh source_dir dest_dir`
        
    - `./greet.sh "Rakib" 25`
        
- Best practices for clear argument handling and user-friendly scripts

---

### üü† **Section 3: Intermediate Concepts (17‚Äì24)**

**17. Reading User Input (read command)**  
‚Üí Interactive input, prompts, timeouts  
üí° _Practice:_ Ask user‚Äôs name and print a welcome

**18. Arrays in Bash**  
‚Üí Indexed arrays, loops, slicing  
üí° _Practice:_ Iterate through an array of fruits

**19. Associative Arrays (Key-Value Pairs)**  
‚Üí `declare -A`, accessing keys and values  
üí° _Practice:_ Build a dictionary of user roles

**20. String Operations**  
‚Üí Length, substring, replace, trim  
üí° _Practice:_ Remove all spaces from a string

**21. Arithmetic in Bash**  
‚Üí `$(( ))`, `expr`, `bc`, increment/decrement  
üí° _Practice:_ Simple calculator script

**22. Date, Time & Formatting**  
‚Üí `date`, epoch, custom format  
üí° _Practice:_ Append current date to backup filename

**23. File Testing & Conditions**  
‚Üí `-f`, `-d`, `-e`, `-s`, `-r`, `-w`, `-x`  
üí° _Practice:_ Check if a directory is writable

**24. Exit Codes & Error Handling**  
‚Üí `$?`, `set -euo pipefail`, error traps  
üí° _Practice:_ Log script failure messages

---

### üîµ **Section 4: Text Processing Power Tools (25‚Äì30)**

**25. Grep Basics ‚Äì Searching Text**  
‚Üí Regex patterns, flags (`-i`, `-r`, `-n`)  
üí° _Practice:_ Find error lines from log file

**26. Sed Basics ‚Äì Stream Editing**  
‚Üí Substitution, delete, insert, inplace edits  
üí° _Practice:_ Replace old domain names in config files

**27. Awk Basics ‚Äì Pattern & Action**  
‚Üí Field processing, print formatting  
üí° _Practice:_ Print name and age from CSV

**28. Combining Grep, Sed & Awk**  
‚Üí Pipeline text processing  
üí° _Practice:_ Build a mini log parser

**29. Find & Xargs Magic**  
‚Üí Search + execute actions on files  
üí° _Practice:_ Delete all `.tmp` files older than 7 days

**30. Cut, Sort, and Uniq**  
‚Üí Column slicing, sorting, duplicate removal  
üí° _Practice:_ Extract unique usernames from a file

---

### üî¥ **Section 5: System, Process & Networking (31‚Äì35)**

**31. Process Management**  
‚Üí `ps`, `top`, `htop`, `kill`, background jobs  
üí° _Practice:_ Find and kill a process by name

**32. Scheduling Tasks ‚Äì Cron & At**  
‚Üí Automating scripts with time  
üí° _Practice:_ Run a backup every midnight

**33. Logging & Monitoring**  
‚Üí `tee`, syslog, custom log function  
üí° _Practice:_ Write logs with timestamps

**34. SSH & Remote Automation**  
‚Üí `ssh`, `scp`, `rsync`, `ssh-copy-id`  
üí° _Practice:_ Copy files between servers securely

**35. Network Utilities in Bash**  
‚Üí `ping`, `curl`, `wget`, `nc`, `dig`  
üí° _Practice:_ Build a website health checker

---

### üü£ **Section 6: Advanced Bash (36‚Äì40)**

**36. Using getopts for CLI Flags**  
‚Üí Parsing command-line options (`-f`, `-v`)  
üí° _Practice:_ Build a CLI tool with flags

**37. Traps, Signals & Cleanup**  
‚Üí `trap`, `SIGINT`, graceful exit  
üí° _Practice:_ Handle Ctrl+C safely in long script

**38. Debugging & Troubleshooting**  
‚Üí `set -x`, `trap ERR`, `bash -x`  
üí° _Practice:_ Debug a broken script

**39. Creating Bash Menus (Interactive UI)**  
‚Üí Case statements, select loops, ASCII menus  
üí° _Practice:_ Build an interactive system menu

**40. Capstone Project ‚Äì DevOps Automation**  
‚Üí Combine all concepts: backup, logs, deploy, notify  
üí° _Practice:_ Create a complete automated deploy script



